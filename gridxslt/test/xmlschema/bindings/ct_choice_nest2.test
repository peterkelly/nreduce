Complex type with some elements and multiple nested <choice>s

=================================== PROGRAM ====================================
genbindings -c
==================================== INPUT =====================================
<?xml version="1.0"?>
<xsd:schema xmlns:xsd="http://www.w3.org/2001/XMLSchema">
  <xsd:complexType name="test">
    <xsd:sequence>
      <xsd:element name="a" type="xsd:int"/>
      <xsd:element name="b" type="xsd:int"/>
      <xsd:choice>
        <xsd:element name="c" type="xsd:int"/>
        <xsd:element name="d" type="xsd:int"/>
        <xsd:element name="e" type="xsd:int"/>
      </xsd:choice>
      <xsd:choice>
        <xsd:element name="f" type="xsd:int"/>
        <xsd:element name="g" type="xsd:int"/>
      </xsd:choice>
      <xsd:choice>
        <xsd:element name="h" type="xsd:int"/>
        <xsd:element name="i" type="xsd:int"/>
      </xsd:choice>
    </xsd:sequence>
  </xsd:complexType>
</xsd:schema>
==================================== OUTPUT ====================================
typedef struct XMLtest1 XMLtest1;
typedef struct XMLtest2 XMLtest2;
typedef struct XMLtest3 XMLtest3;
typedef struct XMLtest XMLtest;

#define XMLtest1_c 1
#define XMLtest1_d 2
#define XMLtest1_e 3

struct XMLtest1 {
  int valtype;
  union {
    int c;
    int d;
    int e;
  } val;
} __attribute__((__packed__));
/* model group - 8 bytes */

#define XMLtest2_f 1
#define XMLtest2_g 2

struct XMLtest2 {
  int valtype;
  union {
    int f;
    int g;
  } val;
} __attribute__((__packed__));
/* model group - 8 bytes */

#define XMLtest3_h 1
#define XMLtest3_i 2

struct XMLtest3 {
  int valtype;
  union {
    int h;
    int i;
  } val;
} __attribute__((__packed__));
/* model group - 8 bytes */

struct XMLtest {
  int a;
  int b;
  XMLtest1 choice;
  XMLtest2 choice1;
  XMLtest3 choice2;
} __attribute__((__packed__));
/* complex type - 32 bytes */

================================== RETURN CODE =================================
0
