//output indent doc = (xml:printxml indent doc)

output indent raw =
(letrec
  nodes = (if indent (xml:add_whitespace raw) raw)
 in
  (append xml:XML_DECL (xml:print_nodes nodes nil)))

getchildren lst =
(if lst
  (if
    (or
      (= (head (head lst)) xml:TYPE_ATTRIBUTE)
      (= (head (head lst)) xml:TYPE_NAMESPACE))
    (getchildren (tail lst))
    lst)
  nil)

getattributes lst =
(if lst
  (if (= (head (head lst)) xml:TYPE_ATTRIBUTE)
    (cons (head lst) (getattributes (tail lst)))
    (if (= (head (head lst)) xml:TYPE_NAMESPACE)
      (getattributes (tail lst))
      nil))
  nil)

getnamespaces lst =
(if lst
  (if (= (head (head lst)) xml:TYPE_NAMESPACE)
    (cons (head lst) (getnamespaces (tail lst)))
    (if (= (head (head lst)) xml:TYPE_ATTRIBUTE)
      (getnamespaces (tail lst))
      nil))
  nil)

////////////////////////////////////////////////////////////////////////////////

getnumber x =
(if (not x)
    nil
(if (tail x)
    nil
(if (!= (head (head x)) xml:TYPE_NUMBER)
    nil
    (tail (head x)))))

range min max = (if (<= min max) (cons (cons xml:TYPE_NUMBER min) (range (+ min 1) max)) nil)

// FIXME: this won't work, item 3 node might fail if it's not an element
nametest name node =
(and (= (head node) xml:TYPE_ELEMENT)
        (streq (item 3 node) name))

attrnametest name node =
(and (= (head node) xml:TYPE_ATTRIBUTE)
        (streq (item 3 node) name))

elementtest node = (= (head node) xml:TYPE_ELEMENT)

texttest node = (= (head node) xml:TYPE_TEXT)

attributetest node = (= (head node) xml:TYPE_ATTRIBUTE)

anykindtest node = 1

apmap3 f lst = (apmap3a f lst 1 (len lst))

apmap3a f lst pos size =
(if lst
    (append (f (head lst) pos size)
            (apmap3a f (tail lst) (+ pos 1) size))
    nil)



filter3 f lst = (filter3a f lst 1 (len lst))

filter3a f lst pos size =
(if lst
    (if (f (head lst) pos size)
        (cons (head lst) (filter3a f (tail lst) (+ pos 1) size))
        (filter3a f (tail lst) (+ pos 1) size))
    nil)


isnode x =
(or (= (head x) xml:TYPE_ELEMENT)
(or (= (head x) xml:TYPE_TEXT)
    (= (head x) xml:TYPE_ATTRIBUTE)))

issingle seq = (if seq (not (tail seq)) nil)

isboolean x = (= (head x) xml:TYPE_BOOLEAN)
isstring x = (= (head x) xml:TYPE_STRING)
isnumber x = (= (head x) xml:TYPE_NUMBER)

// XPath 2.0 2.4.3 - Effective Boolean Value
ebv seq =
(if (not seq)
    nil
(if (isnode (head seq))
    1
(if (not (tail seq))
    (if (isboolean (head seq))
        (tail (head seq))
    (if (isstring (head seq))
        (tail (head seq))
    (if (isnumber (head seq))
        (!= (tail (head seq)) 0)
        nil)))
    nil)))


add x y = (if (or (not x) (not y))
              nil
          (if (or (tail x) (tail y))
              (cons (cons xml:TYPE_ERROR "XPTY0004") nil)
          (if (and (= (head (head x)) xml:TYPE_NUMBER) (= (head (head y)) xml:TYPE_NUMBER))
              (cons (cons xml:TYPE_NUMBER (+ (tail (head x)) (tail (head y)))) nil)
              (cons (cons xml:TYPE_ERROR "FORG0001") nil))))

subtract x y = (if (or (not x) (not y))
              nil
          (if (or (tail x) (tail y))
              (cons (cons xml:TYPE_ERROR "XPTY0004") nil)
          (if (and (= (head (head x)) xml:TYPE_NUMBER) (= (head (head y)) xml:TYPE_NUMBER))
              (cons (cons xml:TYPE_NUMBER (- (tail (head x)) (tail (head y)))) nil)
              (cons (cons xml:TYPE_ERROR "FORG0001") nil))))


multiply x y = (if (or (not x) (not y))
              nil
          (if (or (tail x) (tail y))
              (cons (cons xml:TYPE_ERROR "XPTY0004") nil)
          (if (and (= (head (head x)) xml:TYPE_NUMBER) (= (head (head y)) xml:TYPE_NUMBER))
              (cons (cons xml:TYPE_NUMBER (* (tail (head x)) (tail (head y)))) nil)
              (cons (cons xml:TYPE_ERROR "FORG0001") nil))))

divide x y = (if (or (not x) (not y))
              nil
          (if (or (tail x) (tail y))
              (cons (cons xml:TYPE_ERROR "XPTY0004") nil)
          (if (and (= (head (head x)) xml:TYPE_NUMBER) (= (head (head y)) xml:TYPE_NUMBER))
              (cons (cons xml:TYPE_NUMBER (/ (tail (head x)) (tail (head y)))) nil)
              (cons (cons xml:TYPE_ERROR "FORG0001") nil))))

mod x y = (if (or (not x) (not y))
              nil
          (if (or (tail x) (tail y))
              (cons (cons xml:TYPE_ERROR "XPTY0004") nil)
          (if (and (= (head (head x)) xml:TYPE_NUMBER) (= (head (head y)) xml:TYPE_NUMBER))
              (cons (cons xml:TYPE_NUMBER (% (tail (head x)) (tail (head y)))) nil)
              (cons (cons xml:TYPE_ERROR "FORG0001") nil))))

geneq x y = (if (or (not x) (not y))
              nil
          (if (or (tail x) (tail y))
              (cons (cons xml:TYPE_ERROR "XPTY0004") nil)
          (if (and (= (head (head x)) xml:TYPE_NUMBER) (= (head (head y)) xml:TYPE_NUMBER))
              (cons (cons xml:TYPE_BOOLEAN (= (tail (head x)) (tail (head y)))) nil)
              (cons (cons xml:TYPE_ERROR "FORG0001") nil))))

genne x y = (if (or (not x) (not y))
              nil
          (if (or (tail x) (tail y))
              (cons (cons xml:TYPE_ERROR "XPTY0004") nil)
          (if (and (= (head (head x)) xml:TYPE_NUMBER) (= (head (head y)) xml:TYPE_NUMBER))
              (cons (cons xml:TYPE_BOOLEAN (!= (tail (head x)) (tail (head y)))) nil)
              (cons (cons xml:TYPE_ERROR "FORG0001") nil))))


genlt x y = (if (or (not x) (not y))
              nil
          (if (or (tail x) (tail y))
              (cons (cons xml:TYPE_ERROR "XPTY0004") nil)
          (if (and (= (head (head x)) xml:TYPE_NUMBER) (= (head (head y)) xml:TYPE_NUMBER))
              (cons (cons xml:TYPE_BOOLEAN (< (tail (head x)) (tail (head y)))) nil)
              (cons (cons xml:TYPE_ERROR "FORG0001") nil))))

genle x y = (if (or (not x) (not y))
              nil
          (if (or (tail x) (tail y))
              (cons (cons xml:TYPE_ERROR "XPTY0004") nil)
          (if (and (= (head (head x)) xml:TYPE_NUMBER) (= (head (head y)) xml:TYPE_NUMBER))
              (cons (cons xml:TYPE_BOOLEAN (<= (tail (head x)) (tail (head y)))) nil)
              (cons (cons xml:TYPE_ERROR "FORG0001") nil))))

gengt x y = (if (or (not x) (not y))
              nil
          (if (or (tail x) (tail y))
              (cons (cons xml:TYPE_ERROR "XPTY0004") nil)
          (if (and (= (head (head x)) xml:TYPE_NUMBER) (= (head (head y)) xml:TYPE_NUMBER))
              (cons (cons xml:TYPE_BOOLEAN (> (tail (head x)) (tail (head y)))) nil)
              (cons (cons xml:TYPE_ERROR "FORG0001") nil))))

genge x y = (if (or (not x) (not y))
              nil
          (if (or (tail x) (tail y))
              (cons (cons xml:TYPE_ERROR "XPTY0004") nil)
          (if (and (= (head (head x)) xml:TYPE_NUMBER) (= (head (head y)) xml:TYPE_NUMBER))
              (cons (cons xml:TYPE_BOOLEAN (>= (tail (head x)) (tail (head y)))) nil)
              (cons (cons xml:TYPE_ERROR "FORG0001") nil))))

uminus x = (if (not x)
              nil
          (if (tail x)
              (cons (cons xml:TYPE_ERROR "XPTY0004") nil)
          (if (= (head (head x)) xml:TYPE_NUMBER)
              (cons (cons xml:TYPE_NUMBER (- 0 (tail (head x)))) nil)
              (cons (cons xml:TYPE_ERROR "FORG0001") nil))))

uplus x = (if (not x)
              nil
          (if (tail x)
              (cons (cons xml:TYPE_ERROR "XPTY0004") nil)
          (if (= (head (head x)) xml:TYPE_NUMBER)
              (cons (cons xml:TYPE_NUMBER (tail (head x))) nil)
              (cons (cons xml:TYPE_ERROR "FORG0001") nil))))

normalize1 lst =
(if lst
    lst
    (cons (cons xml:TYPE_STRING "") nil))

isatomic x =
(letrec
   type = (head x)
 in
   (or (= type xml:TYPE_NUMBER)
   (or (= type xml:TYPE_BOOLEAN)
       (= type xml:TYPE_STRING))))

atomic2string x =
(letrec
   type = (head x)
 in
   (if (= type xml:TYPE_NUMBER)
       (cons xml:TYPE_STRING (numtostring (tail x)))
   (if (= type xml:TYPE_BOOLEAN)
       (if (tail x)
           (cons xml:TYPE_STRING "true")
           (cons xml:TYPE_STRING "false"))
   (if (= type xml:TYPE_STRING)
       x
       x))))

normalize2 lst =
(map (!x.if (isatomic x)
            (atomic2string x)
            x)
     lst)

getstrings lst =
(if lst
    (if (= (head (head lst)) xml:TYPE_STRING)
        (appendn 3 " " (tail (head lst)) (getstrings (tail lst)))
        nil)
    lst)

skipstrings lst =
(if lst
    (if (= (head (head lst)) xml:TYPE_STRING)
        (skipstrings (tail lst))
        lst)
    lst)

normalize3 lst =
(if lst
    (if (= (head (head lst)) xml:TYPE_STRING)
        (cons (cons xml:TYPE_STRING (append (tail (head lst)) (getstrings (tail lst))))
              (normalize3 (skipstrings lst)))
        (cons (head lst) (normalize3 (tail lst))))
    nil)

normalize4 lst =
(map (!x.if (= (head x) xml:TYPE_STRING)
            (cons xml:TYPE_TEXT (tail x))
            x)
     lst)

// FIXME: here we should replace document nodes with their children
normalize5 lst = lst

gettexts lst =
(if lst
    (if (= (head (head lst)) xml:TYPE_TEXT)
        (appendn 3 " " (tail (head lst)) (gettexts (tail lst)))
        nil)
    lst)

skiptexts lst =
(if lst
    (if (= (head (head lst)) xml:TYPE_TEXT)
        (skiptexts (tail lst))
        lst)
    nil)

normalize6 lst =
(if lst
    (if (= (head (head lst)) xml:TYPE_TEXT)
        (if (tail (head lst))
            (cons (cons xml:TYPE_TEXT (append (tail (head lst)) (gettexts (tail lst))))
                  (normalize6 (skiptexts lst)))
            (normalize6 (tail lst)))
        (cons (head lst) (normalize6 (tail lst))))
    nil)

// FIXME: check for attribute/namespace nodes and report an error if found
normalize7 lst =
(cons (xml:mkdoc lst) nil)

normalize lst = (normalize7 (normalize6 (normalize5 (normalize4 (normalize3 (normalize2 (normalize1 lst)))))))
//normalize lst = lst



textcontent lst =
(if lst
    (letrec
       cur = (head lst)
       rest = (tail lst)
       type = (head cur)
     in
       (if (= type xml:TYPE_TEXT)
           (append (tail cur) (textcontent rest))
       (if (= type xml:TYPE_ELEMENT)
           (append (textcontent (xml:node_children cur)) (textcontent rest))
       (if (= type xml:TYPE_DOCUMENT)
           (append (textcontent (xml:node_children cur)) (textcontent rest))
           (textcontent rest)))))
    nil)

atomize lst =
(map (!x.(if (isatomic x)
             x
         (if (= (head x) xml:TYPE_TEXT)
             (cons xml:TYPE_STRING (tail x))
         (if (= (head x) xml:TYPE_ATTRIBUTE)
             (cons xml:TYPE_STRING (item 4 x))
         (if (= (head x) xml:TYPE_ELEMENT)
             (cons xml:TYPE_STRING (textcontent (xml:node_children x)))
         (if (= (head x) xml:TYPE_DOCUMENT)
             (cons xml:TYPE_STRING (textcontent (xml:node_children x)))
             (cons xml:TYPE_STRING (append "FIXME(atomize):" (numtostring (head x))))))))))
     lst)


/*******************************************************************************
 * XSLT 2.0 Section 5.7.2
 *
 * Constructing simple content
 ******************************************************************************/

// Discard zero-length txt nodes
consimple1 lst =
(if lst
    (if (= (head (head lst)) xml:TYPE_TEXT)
        (if (tail (head lst)) // string value is non-nil (i.e. non-zero length)
            (cons (head lst) (consimple1 (tail lst))) // keep it
            (consimple1 (tail lst))) // discard it
        (cons (head lst) (consimple1 (tail lst)))) // not a text node
    nil)

// Merge adjacent text nodes (same as sequence normalization step 6)
consimple2 lst = (normalize6 lst)

// Atomize the list
consimple3 lst = (atomize lst)

// Convert all values to strings
consimple4 lst = (map atomic2string lst)

// Concatenate strings (uses a space as the default separator; this should actually be
// configurable)
consimple5 lst = (normalize3 lst)

mergestrings lst =
(if lst
    (if (= (head (head lst)) xml:TYPE_STRING)
        (append (tail (head lst)) (mergestrings (tail lst)))
    (if (= (head (head lst)) xml:TYPE_TEXT)
        (append (tail (head lst)) (mergestrings (tail lst)))
        "ERROR"))
    nil)

consimple lst = (mergestrings (consimple5 (consimple4 (consimple3 (consimple2 (consimple1 lst))))))

/*******************************************************************************
 * XSLT 2.0 Section 5.7.2
 *
 * Constructing complex content
 ******************************************************************************/

// 2. Any atomic value in the sequence is cast to a string.
concomplex2 lst = (map atomic2string lst)

// 3. Any consecutive sequence of strings within the result sequence is converted to a single text
// node, whose string value contains the content of each of the strings in turn, with a single
// space (#x20) used as a separator between successive strings.
concomplex3 lst =
(if lst
    (if (= (head (head lst)) xml:TYPE_STRING)
        (cons (cons xml:TYPE_TEXT (append (tail (head lst)) (getstrings (tail lst))))
              (concomplex3 (skipstrings lst)))
        (cons (head lst) (concomplex3 (tail lst))))
    nil)

concomplex lst = (concomplex3 (concomplex2 lst))

