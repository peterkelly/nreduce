#LyX 1.4.1 created this file. For more info see http://www.lyx.org/
\lyxformat 245
\begin_document
\begin_header
\textclass article
\language british
\inputencoding auto
\fontscheme times
\graphics default
\paperfontsize default
\spacing single
\papersize default
\use_geometry true
\use_amsmath 1
\cite_engine basic
\use_bibtopic false
\paperorientation portrait
\leftmargin 1in
\topmargin 1in
\rightmargin 1in
\bottommargin 1in
\secnumdepth 3
\tocdepth 3
\paragraph_separation skip
\defskip medskip
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\end_header

\begin_body

\begin_layout Section
Sequence constructors
\end_layout

\begin_layout Standard
XSLT has the concept of a 
\emph on
sequence constructor
\emph default
, which is a set of instructions that, when executed, produces a sequence
 of items.
 Some instructions, such as 
\family typewriter
choose
\family default
 and 
\family typewriter
for-each
\family default
, may contain other sequence constructor within child elements.
 The semantics of these are that the resulting sequences are merged together.
 XSLT sequences are 
\begin_inset Quotes eld
\end_inset

flat
\begin_inset Quotes erd
\end_inset

, in that it is not possible for one sequence to contain another.
\end_layout

\begin_layout Standard
Within the generated ELC code, a sequence of items is represented by a list.
 This means that 
\family typewriter
cons
\family default
 must be used by each instruction that adds an item to the list, and that
 the end of the list must be terminated by 
\family typewriter
nil
\family default
.
 For example, to construct a sequence of items a, b, and c, the following
 code would be generated:
\end_layout

\begin_layout LyX-Code
(cons a (cons b (cons c nil)))
\end_layout

\begin_layout Standard
When there are multiple instructions within a sequence constructor, each
 of these may by itself generate a sequence of items (rather than jsut a
 single item).
 In order to merge the lists, the 
\family typewriter
append
\family default
 function must be used; 
\family typewriter
cons
\family default
 would not do here because it would produce nested sequences.
 The 
\family typewriter
genELCSequence
\family default
 compilation function handles the compilation of a sequence constructor
 and generates the appropriate code.
 For three instruction expressions 
\emph on
instr1
\emph default
, 
\emph on
instr2
\emph default
, and 
\emph on
instr3
\emph default
, the following code would be generated:
\end_layout

\begin_layout LyX-Code
(append instr1 (append instr2 instr3))
\end_layout

\begin_layout Standard
Note that in the example above, only two calls to append are needed.
 This is because there are only three lists; a third call to append, if
 present, would take a nil parameter.
 This is not necessary however, since appending nil to a list simply results
 in a copy of the list containing the same values.
 If only one instruction is present in the sequence constructor, it is possible
 to use that expression directly, rather than within a call to 
\family typewriter
append.
\end_layout

\begin_layout Section
Node representation
\end_layout

\begin_layout Standard
Elements
\end_layout

\begin_layout Standard
[TYPE_ELEMENT,name,attributes,children]
\end_layout

\begin_layout Standard
Text
\end_layout

\begin_layout Standard
[TYPE_TEXT,value]
\end_layout

\begin_layout Standard
Attributes
\end_layout

\begin_layout Standard
[TYPE_ATTRIBUTE,name,value]
\end_layout

\begin_layout Standard
\begin_inset Formula \begin{eqnarray*}
\mathrm{Element} &  & \left[\mathrm{TYPE\_ELEMENT},name,attributes,children\right]\\
\mathrm{Text} &  & \left[\mathrm{TYPE\_TEXT},value\right]\\
\mathrm{Attribute} &  & \left[\mathrm{TYPE\_ATTRIBUTE},name,value\right]\end{eqnarray*}

\end_inset


\end_layout

\begin_layout Section
Compilation rules
\end_layout

\begin_layout Standard
\align center
\begin_inset Formula $\begin{array}{lcl}
Term & : & Number\mid Nil\mid Variable\mid Function\\
Expr & : & Term\mid Expr\; Term\mid\left(Expr\right)\\
d & : & Number\\
s & : & String\\
\\\end{array}$
\end_inset


\end_layout

\begin_layout Standard
\align center
\begin_inset Formula $\begin{array}{lcl}
X & : & Expr\rightarrow ELC\\
\mathrm{X}\left[\!\left[d\right]\!\right] & = & \left(\mathrm{cons}\; d\;\mathrm{nil}\right)\\
\mathrm{X}\left[\!\left[s\right]\!\right] & = & \left(\mathrm{cons}\; s\;\mathrm{nil}\right)\\
\mathrm{X}\left[\!\left[e_{1}+e_{2}\right]\!\right] & = & \left(\mathrm{cons}\;\left(+\;\left(\mathrm{head}\;\mathrm{X}\left[\!\left[e_{1}\right]\!\right]\right)\;\left(\mathrm{head}\;\mathrm{X}\left[\!\left[e_{2}\right]\!\right]\right)\right)\;\mathrm{nil}\right)\\
\mathrm{X}\left[\!\left[e_{1}\;\mathrm{to}\; e_{2}\right]\!\right] & = & \left(\mathrm{cons}\;\left(\mathrm{range}\;\left(\mathrm{head}\;\mathrm{X}\left[\!\left[e_{1}\right]\!\right]\right)\;\left(\mathrm{head}\;\mathrm{X}\left[\!\left[e_{2}\right]\!\right]\right)\right)\;\mathrm{nil}\right)\\
\mathrm{X}\left[\!\left[e_{1}/e_{2}\right]\!\right] & = & \left(\mathrm{apmap3}\;\left(\lambda citem.\lambda cpos.\lambda csize.\mathrm{X}\left[\!\left[e_{2}\right]\!\right]\right)\;\mathrm{X}\left[\!\left[e_{1}\right]\!\right]\right)\\
\mathrm{X}\left[\!\left[e_{1}\left[e_{2}\right]\right]\!\right] & = & \left(\mathrm{filter3}\;\left(\lambda citem.\lambda cpos.\lambda csize.\mathrm{ebv}\;\mathrm{X}\left[\!\left[e_{2}\right]\!\right]\right)\;\mathrm{X}\left[\!\left[e_{1}\right]\!\right]\right)\\
\mathrm{X}\left[\!\left[name\right]\!\right] & = & \left(\mathrm{filter}\;\left(\mathrm{nametest}\; name\right)\;\left(\mathrm{item}\;3\; citem\right)\right)\\
\mathrm{X}\left[\!\left[\mathtt{element()}\right]\!\right] & = & \left(\mathrm{filter}\;\left(\lambda n.=\;\left(\mathrm{head}\; n\right)\;\mathrm{TYPE\_ELEMENT}\right)\;\left(\mathrm{item}\;3\; citem\right)\right)\\
\mathrm{X}\left[\!\left[\mathtt{text()}\right]\!\right] & = & \left(\mathrm{filter}\;\left(\lambda n.=\;\left(\mathrm{head}\; n\right)\;\mathrm{TYPE\_TEXT}\right)\;\left(\mathrm{item}\;3\; citem\right)\right)\\
\mathrm{X}\left[\!\left[\mathtt{attribute()}\right]\!\right] & = & \left(\mathrm{filter}\;\left(\lambda n.=\;\left(\mathrm{head}\; n\right)\;\mathrm{TYPE\_ATTRIBUTE}\right)\;\left(\mathrm{item}\;3\; citem\right)\right)\\
\mathrm{X}\left[\!\left[\mathtt{node()}\right]\!\right] & = & \left(\mathrm{filter}\;\left(\lambda n.\mathrm{isnode}\; n\right)\;\left(\mathrm{item}\;3\; citem\right)\right)\end{array}$
\end_inset


\end_layout

\end_body
\end_document
