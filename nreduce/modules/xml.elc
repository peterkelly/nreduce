XML_DECL = "<?xml version=\"1.0\" encoding=\"UTF-8\"?>"

WSDL_NS = "http://schemas.xmlsoap.org/wsdl/"
SOAP_NS = "http://schemas.xmlsoap.org/wsdl/soap/"
SOAPENV_NS ="http://schemas.xmlsoap.org/soap/envelope/"
XSD_NS = "http://www.w3.org/2001/XMLSchema"
XSI_NS = "http://www.w3.org/2001/XMLSchema-instance"
XMLNS_NS = "http://www.w3.org/2000/xmlns/"

TYPE_ELEMENT    = 0
TYPE_TEXT       = 1
TYPE_COMMENT    = 2
TYPE_ATTRIBUTE  = 3
TYPE_DOCUMENT   = 4
TYPE_STRING     = 5
TYPE_BOOLEAN    = 6
TYPE_NUMBER     = 7
TYPE_ERROR      = 8

NODE_NAMES = "ELEMENT", "TEXT", "ATTRIBUTE", "DOCUMENT", "STRING", "BOOLEAN", "NUMBER", "ERROR", nil

TOKEN_STARTELEM = 0
TOKEN_ENDELEM = 1
TOKEN_TEXT = 2
TOKEN_ATTRNAME = 3
TOKEN_ATTRVALUE = 4
TOKEN_COMMENT = 5

TOKEN_NAMES = "STARTELEM", "ENDELEM", "TEXT", "ATTRNAME", "ATTRVALUE", "COMMENT", nil

//==================================================================================================
// xml:tokenize stream
//
// This function is used internally by the XML parser. It takes a stream of data representing an
// XML document, and converts it into a list of tokens. Each token is a cons pair with the head
// containing the token type (one of the TOKEN_* constants), and the tail set to a string value.
// This token stream is interpreted by the parser to build up a tree of XML nodes.
//
// Possible token types are: STARTELEM, ENDELEM, TEXT, ATTRNAME, ATTRVALUE
//
// States of the tokenizer are: main, pi, piend, skipspace, namestart, name, endname, leafend,
// attrsearch, attrname, eqsearch, valsearch, and value.
//
// The tokenizer is implemented as a state machine, with each state represented by a different
// function. In each state, the tokenizer first checks if there is any more data in the stream,
// returning nil if the end of the stream is encountered. It then looks at the current character,
// and depending on its value, either stays in the same state and incremenets the character count
// for that token, or switches to a new state (optionally producing a token). A token is "produced"
// by returning a cons pair where the head is the token and the tail is a continuation which can
// later be invoked to obtain futher tokens.
//
// Lazy evaluation is used for the tokenization, so that the parser can begin constructing the
// element tree before the whole stream has arrived. If a program that uses the XML module only
// accesses the first part of a document, the rest of the document does not need to be parsed,
// tokenized, or read from the data source. If an attempt is made to obtain the next token from
// the stream, and the necessary data is not yet available, then the caller will block; this can
// happen for example when reading XML data over a slow network connection.
//==================================================================================================

tokenize stream = (tokenize_skipspace stream)

tokenize_main !stream !start !count =
(if stream
  (letrec !c = (head stream) !rest = (tail stream) in
    (if (= c '<')
      (if (> count 0)
        (cons (cons TOKEN_TEXT (prefix count start))
          (tokenize_namestart rest))
        (tokenize_namestart rest))
      (tokenize_main rest start (+ count 1))))
  nil)

tokenize_pi !stream =
(if stream
  (letrec !c = (head stream) !rest = (tail stream) in
    (if (= c '?')
      (tokenize_piend rest)
      (tokenize_pi rest)))
  (error "XML parse error: unexpected end of input in processing instruction"))

tokenize_piend !stream =
(if stream
  (letrec !c = (head stream) !rest = (tail stream) in
    (if (= c '>')
      (tokenize_skipspace rest)
      (tokenize_pi rest)))
  (error "XML parse error: unexpected end of input in processing instruction end"))

tokenize_skipspace !stream =
(if stream
  (letrec !c = (head stream) !rest = (tail stream) in
    (if (isspace c)
      (tokenize_skipspace rest)
      (tokenize_main stream stream 0)))
  nil)

tokenize_namestart !stream =
(if stream
  (letrec !c = (head stream) !rest = (tail stream) in
    (if (= c '/')
      (tokenize_endname rest rest 0)
      (if (= c '?')
        (tokenize_pi rest)
        (if (= c '!')
          (tokenize_comment1 rest stream)
          (tokenize_name stream stream 0)))))
  (error "XML parse error: unexpected end of input at start of element name"))

tokenize_comment1 !stream !start =
(if stream
  (letrec !c = (head stream) !rest = (tail stream) in
    (if (= c '-')
      (tokenize_comment2 rest start)
      (tokenize_name start start 0)))
  (error "XML parse error: unexpected end of input at start of comment"))

tokenize_comment2 !stream !start =
(if stream
  (letrec !c = (head stream) !rest = (tail stream) in
    (if (= c '-')
      (tokenize_comment rest rest 0)
      (tokenize_name start start 0)))
  (error "XML parse error: unexpected end of input at start of comment"))

tokenize_comment !stream !start !count =
(if stream
  (letrec !c = (head stream) !rest = (tail stream) in
    (if (= c '-')
      (tokenize_comment_end1 rest start (+ count 1))
      (tokenize_comment rest start (+ count 1))))
  (error "XML parse error: unexpected end of input in comment"))

tokenize_comment_end1 !stream !start !count =
(if stream
  (letrec !c = (head stream) !rest = (tail stream) in
    (if (= c '-')
      (tokenize_comment_end2 rest start (+ count 1))
      (tokenize_comment rest start (+ count 1))))
  (error "XML parse error: unexpected end of input in comment"))

tokenize_comment_end2 !stream !start !count =
(if stream
  (letrec !c = (head stream) !rest = (tail stream) in
    (if (= c '>')
      (cons (cons TOKEN_COMMENT (prefix (- count 2) start))
        (tokenize_main rest rest 0))
      (tokenize_comment rest start (+ count 1))))
  (error "XML parse error: unexpected end of input in comment"))

tokenize_name !stream !start !count =
(if stream
  (letrec !c = (head stream) !rest = (tail stream) in
    (if (= c '>')
      (cons (cons TOKEN_STARTELEM (prefix count start))
        (tokenize_main rest rest 0))
      (if (= c '/')
        (cons (cons TOKEN_STARTELEM (prefix count start))
          (tokenize_leafend rest))
        (if (isspace c)
          (cons (cons TOKEN_STARTELEM (prefix count start))
            (tokenize_attrsearch rest))
          (tokenize_name rest start (+ count 1))))))
  (error (append "XML parse error: unexpected end of input in open tag: " start)))

tokenize_endname !stream !start !count =
(if stream
  (letrec !c = (head stream) !rest = (tail stream) in
    (if (= c '>')
      (cons (cons TOKEN_ENDELEM nil)
        (tokenize_main rest rest 0))
      (tokenize_endname rest start (+ count 1))))
  (error (append "XML parse error: unexpected end of input in close tag: " start)))

tokenize_leafend !stream =
(if stream
  (letrec !c = (head stream) !rest = (tail stream) in
    (if (= c '>')
      (cons (cons TOKEN_ENDELEM nil)
        (tokenize_main rest rest 0))
      (error (append "XML parse error: invalid character after / in open tag: " stream))))
  (error "XML parse error: unexpected end of input in standalone tag"))

tokenize_attrsearch !stream =
(if stream
  (letrec !c = (head stream) !rest = (tail stream) in
    (if (= c '>')
      (tokenize_main rest rest 0)
      (if (= c '/')
        (tokenize_leafend rest)
        (if (isspace c)
          (tokenize_attrsearch rest)
          (tokenize_attrname rest stream 0)))))
  (error "XML parse error: unexpected end of input in open tag"))

tokenize_attrname !stream !start !count =
(if stream
  (letrec !c = (head stream) !rest = (tail stream) in
    (if (or (= c '=') (isspace c))
      (cons (cons TOKEN_ATTRNAME (prefix (+ count 1) start))
        (tokenize_eqsearch stream))
      (tokenize_attrname rest start (+ count 1))))
  (error "XML parse error: unexpected end of input in attribute name"))

tokenize_eqsearch !stream =
(if stream
  (letrec !c = (head stream) !rest = (tail stream) in
    (if (= c '=')
      (tokenize_valsearch rest)
      (if (isspace c)
        (tokenize_eqsearch rest)
        nil)))
  (error "XML parse error: unexpected end of input in attribute"))

tokenize_valsearch !stream =
(if stream
  (letrec !c = (head stream) !rest = (tail stream) in
    (if (= c '>')
      (tokenize_main rest rest 0)
      (if (= c '\"')
        (tokenize_value_dq rest rest 0)
        (if (= c '\'')
          (tokenize_value_sq rest rest 0)
          (if (isspace c)
            (tokenize_valsearch rest)
            nil)))))
  (error "XML parse error: unexpected end of input in attribute value"))

tokenize_value_dq !stream !start !count =
(if stream
  (letrec !c = (head stream) !rest = (tail stream) in
    (if (= c '\"')
      (cons (cons TOKEN_ATTRVALUE (prefix count start))
        (tokenize_attrsearch rest))
      (tokenize_value_dq rest start (+ count 1))))
  (error "XML parse error: unexpected end of input in attribute value"))

tokenize_value_sq !stream !start !count =
(if stream
  (letrec !c = (head stream) !rest = (tail stream) in
    (if (= c '\'')
      (cons (cons TOKEN_ATTRVALUE (prefix count start))
        (tokenize_attrsearch rest))
      (tokenize_value_sq rest start (+ count 1))))
  (error "XML parse error: unexpected end of input in attribute value"))

isspace c = (or (= c ' ') (or (= c '\r') (= c '\n')))

//==================================================================================================
// xml:print_tokens tokens
//
// Debugging function for printing out the result of the tokenization process
//==================================================================================================

print_tokens !tokens =
(if (not tokens)
  nil
  (letrec
    !tok = (head tokens)
    !rest = (tail tokens)
   in
    (appendn 5 (item (head tok) TOKEN_NAMES) ": \""
      (print_token (tail tok)) "\"\n"
      (print_tokens rest))))

print_token val =
(if val
  (if (= (head val) '\r')
    (append "\\r" (print_token (tail val)))
    (if (= (head val) '\n')
      (append "\\n" (print_token (tail val)))
      (cons (head val) (print_token (tail val)))))
  nil)

//==================================================================================================
// xml:add_whitespace nodes
//
// Produces a new copy of an XML element tree that contains whitespace added for indenting
// purposes. The whitespace is in the form of new text nodes containing a newline and some spaces.
// The indenting is done in accordance with the rules of section 5.1.3 of the XSLT 2.0 and
// XQuery 1.0 Serialization spec, which says that it can only be added in places where it does
// not alter the meaning of the document, i.e. the new whitespace must not be considered
// "significant".
//
// The main part of the work is done by add_whitespace1. This accepts a needindent parameter,
// specifying whether a new element that is encountered should have indentation added before it,
// of in the case of the end of the list, whether whitespace should be added. It also has a
// haveindent parameter, which records the number of characters encountered so far that are the
// same as what would be added; if a document already contains some indentation then only the
// necessary spaces will be added.
//==================================================================================================

add_whitespace nodes =
(add_whitespace1 0 nodes nil 0)

add_whitespace1 depth lst needindent haveindent =
(if lst
  (letrec
    this = (head lst)
    rest = (tail lst)
    type = (head this)
   in
    (if (= type TYPE_ELEMENT)
      (letrec
        nsuri = (item 1 this)
        nsprefix = (item 2 this)
        localname = (item 3 this)
        attributes = (item 4 this)
        namespaces = (item 5 this)
        children = (item 6 this)
       in
        (maybe_indent depth needindent haveindent
          (cons
            (mkelem nsuri nsprefix localname attributes namespaces
              (if children
                (add_whitespace1 (+ depth 1) children 1 0)
                nil))
            (add_whitespace1 depth rest 1 0))))
      (if (= type TYPE_TEXT)
        (letrec
          str = (tail this)
          newhave = (count_indent str haveindent)
          nws = (isnonws str)
         in
          (cons
            this
            (if nws
              (add_whitespace1 depth rest nil 0)
              (add_whitespace1 depth rest needindent newhave))))
        (if (= type TYPE_COMMENT)
          (maybe_indent depth needindent haveindent
            (cons
              this
              (add_whitespace1 depth rest nil 0)))
          (if (= type TYPE_DOCUMENT)
            (letrec
              children = (tail this)
             in
              (cons
                (mkdoc (add_whitespace1 depth children 1 0))
                (add_whitespace1 depth rest nil 0)))
            nil)))))
  (if (> depth 0)
    (maybe_indent (- depth 1) needindent haveindent nil)
    nil))

//==================================================================================================
// xml:count_indent
//
// Count the number of indentation characters present in a string. A set of indentation characters
// consists of a newline followed by one or more spaces. If a non-whitespace character is found,
// then this is the end of a possible indentation string and we must start from the beginning.
// The number of indentation characters already existing in previous text nodes is specified in the
// haveindent argument.
//==================================================================================================
count_indent str haveindent =
(if str
  (letrec
    c = (head str)
    rest = (tail str)
   in
    (if (= c '\n')
      (count_indent rest 1)
      (if (and (= c ' ') (> haveindent 0))
        (count_indent rest (+ haveindent 1))
        (count_indent rest 0))))
  haveindent)

//==================================================================================================
// xml:isnonws str
//
// Determines if a string contains any non-whitespace characters
//==================================================================================================
isnonws str =
(if str
  (if (isspace (head str))
    (isnonws (tail str))
    1)
  nil)

//==================================================================================================
// xml:maybe_indent depth needindent haveindent rest
//
// This function is used by add_whitespace
//
// Possibly add some whitespace to the document for indentation purposes. This is done only if
// needindent is true. If it is, then the depth and havindent is used to determine how much
// whitespace to add. A haveindent value of 0 means that there is no existing whitespace, and a
// newline and depth*3 spaces should be added. A haveindent value of 1 means that the newline
// is already there, so depth*3 spaces are needed. A haveindent value greater than 1 means that
// the newline is there, as well as (haveindent-1) spaces.
//==================================================================================================
maybe_indent depth needindent haveindent rest =
(if needindent
  (if (> haveindent 0)
    (cons (mktext (spaces (- (* depth 3) (- haveindent 1)))) rest)
    (cons (mktext (append "\n" (spaces (* depth 3)))) rest))
  rest)

//==================================================================================================
// xml:spaces n
//
// Returns a string consisting of n spaces
//==================================================================================================
spaces n =
(letrec
  bulkspaces = (append "                                                            " bulkspaces)
in
(prefix n bulkspaces))

//==================================================================================================
// xml:parse tokens
//
// Construct an XML node tree from a stream of input tokens
//
// This function implements the second half of the logic necessary to create an XML structure from
// a data stream. The function xml:tokenizer must be called to create the token stream, and the
// result passed to this function.
//
// The parser starts off by traversing through the list of tokens. When it encounters a
// START_ELEMENT token, it creates a new element node, with the attributes, namespaces, and
// children constructed from the tokens that appear immediately afterwards. During parsing, the
// current depth is kept track of; this increases when a STARTELEM is encountered, and decreases
// when ENDELEM is encountered. If an ENDELEM token is found and the depth is equal to the current
// depth, then we know that is the end of the set of tokens that comprise the children of this
// element.
//
// In order to parse the next element at this level in the tree, we must skip over all these tokens.
// This is taken care of by the skip_level function. The remainingtokens variable is set to the
// result of this, and the call to parse to create the following sibling of this node is passed
// this set of tokens.
//
// All of the parsing is done lazily. If the caller of this function never accesses parts of the
// tree later on, then these tree segments will never be constructed, and the tokenizer will never
// be asked for the tokens, which means that is is not necessary to read the rest of the data
// stream.
//==================================================================================================

parse tokens = (parse1 tokens nil 0)

parse1 tokens namespaces !depth =
(if (not tokens)
  (if (> depth 1)
    (error "XML parse error: missing close tag at end of input")
    nil)
  (letrec
    cur = (head tokens)
    rest = (tail tokens)
    tag = (head cur)
   in
    (if (= tag TOKEN_STARTELEM)
      (letrec
        augnamespaces = (cons newnamespaces namespaces)
        children = (skip_attrs rest augnamespaces (+ depth 1))
        attributes = (parse_attrs rest augnamespaces)
        newnamespaces = (parse_namespaces rest)
        remainingtokens = (skip_level rest 0)
        qname = (tail cur)
        nsprefix = (getnsprefix qname)
        nsuri = (ns_lookup nsprefix augnamespaces)
        localname = (getlocalname qname)
       in
        (cons
          (mkelem nsuri nsprefix localname attributes newnamespaces children)
          (parse1 remainingtokens namespaces depth)))
      (if (= tag TOKEN_ENDELEM)
        nil
        (if (= tag TOKEN_ATTRNAME)
          nil
          (if (= tag TOKEN_TEXT)
            (cons (mktext (tail cur)) (parse1 rest namespaces depth))
            (if (= tag TOKEN_COMMENT)
              (cons (mkcomment (tail cur)) (parse1 rest namespaces depth))
              (parse1 rest namespaces depth))))))))

//==================================================================================================
// xml:skip_attrs tokens namespaces depth
//
// Skip past the ATTRNAME and ATTRVALUE tokens in a token stream.
//
// When the tokenizer parses the open tag of an element, it adds one of each of these tokens for
// each attribute encountered. Any elements, text nodes, comments etc. that are children of the
// element will appear after the attributes. Thus, to get to the portion of the token stream
// representing the children of a node, we simply need to skip past these.
//==================================================================================================
skip_attrs tokens namespaces !depth =
(if (not tokens)
  nil
  (letrec
    cur = (head tokens)
    rest = (tail tokens)
    tag = (head cur)
   in
    (if (or (= tag TOKEN_ATTRNAME) (= tag TOKEN_ATTRVALUE))
      (skip_attrs rest namespaces depth)
      (parse1 tokens namespaces depth))))

//==================================================================================================
// xml:parse_namespaces tokens
//
// Constructs a list of namespace mappings based on a set of ATTRNAME and ATTRVALUE tokens.
//
// Each attribute name/value pair in the current element is inspected to see if it is an XML
// namespace declaration, i.e. if it is of the form xmlns:something="..." or xmlns="...". If so,
// a namespace mapping consisting of a cons pair with the prefix and namespace URI is created, and
// added to the list. Attributes other than namespace declarations are ignored.
//
// This function looks no further than the attributes specified for this element. If a tag other
// than ATTRNAME or ATTRVALUE is encountered, it means that the next part of the token stream
// corresponds to a child node, or a close tag (the ENDELEM token).
//==================================================================================================
parse_namespaces tokens =
(if (not tokens)
  nil
  (letrec
    cur = (head tokens)
    rest = (tail tokens)
    tag = (head cur)
   in
    (if (= tag TOKEN_ATTRNAME)
      (letrec
        value = (tail (head rest))
        rest2 = (tail rest)
        qname = (tail cur)
        nsprefix = (getnsprefix qname)
        localname = (getlocalname qname)
       in
        (if (streq nsprefix "xmlns")
          (cons
            (cons localname value)
            (parse_namespaces rest2))
          (if (and (not nsprefix) (streq localname "xmlns"))
            (cons
              (cons nil value)
              (parse_namespaces rest2))
            (parse_namespaces rest2))))
      nil)))

//==================================================================================================
// xml:parse_attrs tokens namespaces
//
// Constructs a list of XML attribute nodes corresponding to the ATTRNAME and ATTRVALUE tokens
// found in a token stream.
//
// The token stream is traversed to find the attribute declarations. When a token other than
// ATTRNAME or ATTRVALUE is encountered, this function knows that it has found all the attributes,
// since the next token will either be the first child node or the close tag of the current element.
//
// For each ATTRNAME/ATTRVALUE pair, an attribute node is created, containing the namespace URI,
// prefix, localname, and value. The returned list of nodes is used as the attributes property of
// an element.
//==================================================================================================
parse_attrs tokens namespaces =
(if (not tokens)
  nil
  (letrec
    cur = (head tokens)
    rest = (tail tokens)
    tag = (head cur)
   in
    (if (= tag TOKEN_ATTRNAME)
      (letrec
        value = (tail (head rest))
        rest2 = (tail rest)
        qname = (tail cur)
        nsprefix = (getnsprefix qname)
        nsuri = (ns_lookup nsprefix namespaces)
        localname = (getlocalname qname)

       in
        // Check if it's a namespace attribute; if so, skip this one
        (if (streq nsprefix "xmlns")
          (parse_attrs rest2 namespaces)
          (if (and (not nsprefix) (streq localname "xmlns"))
            (parse_attrs rest2 namespaces)
            // It's a normal attribute; add it to the list
            (cons
              (mkattr nsuri nsprefix localname value)
              (parse_attrs rest2 namespaces)))))
      nil)))

//==================================================================================================
// xml:skip_level tokens level
//
// Skip past the portion of a token stream that contains the tokens for children of a node.
//
// This function is used by the parser to obtain the part of the token stream that needs to be
// parsed for the following sibling of a node. It traverses through the stream, keeping track of
// the current level, based on the appearance of STARTELEM or ENDELEM tokens. When an ENDELEM token
// is found, and the current level is 0, then it returns the remainder of the token stream.
//==================================================================================================
skip_level tokens level =
(if tokens
  (letrec
    cur = (head tokens)
    rest = (tail tokens)
    tag = (head cur)
   in
    (if (= tag TOKEN_STARTELEM)
      (skip_level rest (+ level 1))
      (if (= tag TOKEN_ENDELEM)
        (if (= level 0)
          rest
          (skip_level rest (- level 1)))
        (skip_level rest level))))
  nil)

//==================================================================================================

mkelem nsuri nsprefix localname attributes namespaces children =
(cons TYPE_ELEMENT
  (cons nsuri
    (cons nsprefix
      (cons localname
        (cons attributes
          (cons namespaces
            (cons children nil)))))))

mkdoc children = (cons TYPE_DOCUMENT children)

mkattr nsuri nsprefix localname value =
(cons TYPE_ATTRIBUTE
  (cons nsuri
    (cons nsprefix
      (cons localname
        (cons value nil)))))

mktext value =
(cons TYPE_TEXT value)

mkcomment value =
(cons TYPE_COMMENT value)

node_children node =
(if (= (head node) TYPE_ELEMENT)
  (item 6 node)
  (if (= (head node) TYPE_DOCUMENT)
    (tail node)
    nil))

node_attributes node =
(if (= (head node) TYPE_ELEMENT)
  (item 4 node)
  nil)

getnsprefix1 str start !count =
(if str
  (if (= (head str) ':')
    (prefix count start)
    (getnsprefix1 (tail str) start (+ count 1)))
  nil)

getnsprefix qname = (getnsprefix1 qname qname 0)

getlocalname1 qname start =
(if qname
  (if (= (head qname) ':')
    (tail qname)
    (getlocalname1 (tail qname) start))
  start)

getlocalname qname = (getlocalname1 qname qname)

get_attribute1 nsuri localname attrs =
(if attrs
  (letrec
    attr = (head attrs)
   in
    (if
      (and
        (streq (item 1 attr) nsuri)
        (streq (item 3 attr) localname))
      (item 4 attr)
      (get_attribute1 nsuri localname (tail attrs))))
  nil)

get_attribute nsuri localname elem =
(letrec
  attrs = (item 4 elem)
 in
  (get_attribute1 nsuri localname attrs))

ns_lookup1 nsprefix lst =
(if lst
  (letrec
    ns = (head lst)
    prefix = (head ns)
    value = (tail ns)
   in
    (if (streq prefix nsprefix)
      value
      (ns_lookup1 nsprefix (tail lst))))
  nil)

ns_lookup2 nsprefix nslists =
(if nslists
  (letrec
    nsuri = (ns_lookup1 nsprefix (head nslists))
   in
    (if nsuri
      nsuri
      (ns_lookup2 nsprefix (tail nslists))))
  nil)

ns_lookup nsprefix nslists =
(if (streq nsprefix "xmlns")
  XMLNS_NS
  (ns_lookup2 nsprefix nslists))

// FIXME: need to escape element/attribute names and values when printing

apmap lst fun = (if lst (append (fun (head lst)) (apmap (tail lst) fun)) nil)

print_attrs lst next =
(if lst
  (letrec
    attr = (head lst)
    nsuri = (item 1 attr)
    nsprefix = (item 2 attr)
    localname = (item 3 attr)
    qname = (if nsprefix (append nsprefix (cons ':' localname)) localname)
    //qname = (if nsuri (cons '{' (append nsuri (cons '}' localname))) localname)
   in
    (append " "
      (append qname
        (append "=\""
          (append (item 4 attr)
            (append "\"" (print_attrs (tail lst) next)))))))
  next)

print_namespaces lst next =
(if lst
  (letrec
    cur = (head lst)
    nsprefix = (head cur)
    nsuri = (tail cur)
   in
    (append " xmlns:"
      (append nsprefix
        (append "=\""
          (append nsuri
            (append "\"" (print_namespaces (tail lst) next)))))))
  next)

print_nodes lst next =
(if lst
  (letrec
    node = (head lst)
    rest = (tail lst)
   in
    (if (= (head node) TYPE_ELEMENT)
      (letrec
        nsuri = (item 1 node)
        nsprefix = (item 2 node)
        localname = (item 3 node)
        attributes = (item 4 node)
        namespaces = (item 5 node)
        children = (item 6 node)
        qname = (if nsprefix (append nsprefix (cons ':' localname)) localname)
       //qname = (if nsuri (cons '{' (append nsuri (cons '}' localname))) localname)
       in
        (if children
          (cons '<'
            (append qname
              (print_namespaces namespaces
                (print_attrs attributes
                  (cons '>'
                    (print_nodes children
                      (cons '<'
                        (cons '/'
                          (append qname
                            (append ">"
                              (print_nodes rest next)))))))))))
          (cons '<'
            (append qname
              (print_namespaces namespaces
                (print_attrs attributes
                  (append "/>" (print_nodes rest next))))))))
      (if (= (head node) TYPE_TEXT)
        (append (tail node) (print_nodes rest next))
        (if (= (head node) TYPE_COMMENT)
          (append "<!--" (append (tail node) (append "-->" (print_nodes rest next))))
          (if (= (head node) TYPE_DOCUMENT)
            (print_nodes (tail node) (print_nodes rest next))
            (append "OTHER: " (append (numtostring (head node)) (print_nodes rest next))))))))
  next)

////////////////////////////////////////////////////////////////////////////////

stripspaces lst =
(if lst
  (letrec
    cur = (head lst)
    rest = (tail lst)
    type = (head cur)
   in
    (if (= type TYPE_ELEMENT)
      (cons
        (mkelem
          (item 1 cur) // nsuri
          (item 2 cur) // nsprefix
          (item 3 cur) // localname
          (item 4 cur) // attributes
          (item 5 cur) // namespaces
          (stripspaces (item 6 cur))) (stripspaces rest))
      (if (= type TYPE_TEXT)
        (if (isnonws (tail cur))
          (cons cur (stripspaces rest))
          (stripspaces rest))
        (cons cur (stripspaces rest)))))
  nil)

parsexml strip stream =
(letrec
 input = (parse (tokenize stream))
 input2 = (if strip (stripspaces input) input)
 in
  (mkdoc input2))

printxml indent root =
(letrec
  raw = (cons root nil)
  nodes = (if indent (add_whitespace raw) raw)
 in
  (append XML_DECL (print_nodes nodes nil)))
