XML_DECL = "<?xml version=\"1.0\" encoding=\"UTF-8\"?>"

WSDL_NS = "http://schemas.xmlsoap.org/wsdl/"
SOAP_NS = "http://schemas.xmlsoap.org/wsdl/soap/"
SOAPENV_NS ="http://schemas.xmlsoap.org/soap/envelope/"
XSD_NS = "http://www.w3.org/2001/XMLSchema"
XSI_NS = "http://www.w3.org/2001/XMLSchema-instance"
XMLNS_NS = "http://www.w3.org/2000/xmlns/"

TYPE_STRING     = 0
TYPE_BOOLEAN    = 1
TYPE_NUMBER     = 2
TYPE_QNAME      = 3
UNTYPED_ATOMIC  = 4

MAX_ATOMIC_TYPE = 4

TYPE_ELEMENT    = 5
TYPE_TEXT       = 6
TYPE_COMMENT    = 7
TYPE_ATTRIBUTE  = 8
TYPE_NAMESPACE  = 9
TYPE_DOCUMENT   = 10

TYPE_ERROR      = 11

// FIXME
xNODE_NAMES = "ELEMENT", "TEXT", "COMMENT", "ATTRIBUTE", "NAMESPACE", "DOCUMENT", "STRING",
"BOOLEAN", "NUMBER", "QNAME", "UNTYPED_ATOMIC", "ERROR", nil

TOKEN_STARTELEM = 0
TOKEN_ENDELEM = 1
TOKEN_TEXT = 2
TOKEN_ATTRNAME = 3
TOKEN_ATTRVALUE = 4
TOKEN_COMMENT = 5

TOKEN_NAMES = "STARTELEM", "ENDELEM", "TEXT", "ATTRNAME", "ATTRVALUE", "COMMENT", nil

//==================================================================================================
// xml:tokenize stream
//
// This function is used internally by the XML parser. It takes a stream of data representing an
// XML document, and converts it into a list of tokens. Each token is a cons pair with the head
// containing the token type (one of the TOKEN_* constants), and the tail set to a string value.
// This token stream is interpreted by the parser to build up a tree of XML nodes.
//
// Possible token types are: STARTELEM, ENDELEM, TEXT, ATTRNAME, ATTRVALUE
//
// States of the tokenizer are: main, pi, piend, skipspace, namestart, name, endname, leafend,
// attrsearch, attrname, eqsearch, valsearch, and value.
//
// The tokenizer is implemented as a state machine, with each state represented by a different
// function. In each state, the tokenizer first checks if there is any more data in the stream,
// returning nil if the end of the stream is encountered. It then looks at the current character,
// and depending on its value, either stays in the same state and incremenets the character count
// for that token, or switches to a new state (optionally producing a token). A token is "produced"
// by returning a cons pair where the head is the token and the tail is a continuation which can
// later be invoked to obtain futher tokens.
//
// Lazy evaluation is used for the tokenization, so that the parser can begin constructing the
// element tree before the whole stream has arrived. If a program that uses the XML module only
// accesses the first part of a document, the rest of the document does not need to be parsed,
// tokenized, or read from the data source. If an attempt is made to obtain the next token from
// the stream, and the necessary data is not yet available, then the caller will block; this can
// happen for example when reading XML data over a slow network connection.
//==================================================================================================

tokenize stream = (tokenize_skipspace stream)

tokenize_main !stream !start !count =
(if stream
  (letrec !c = (head stream) !rest = (tail stream) in
    (if (= c '<')
      (if (> count 0)
        (cons (cons TOKEN_TEXT (prefix count start))
          (tokenize_namestart rest))
        (tokenize_namestart rest))
      (tokenize_main rest start (+ count 1))))
  nil)

tokenize_pi !stream =
(if stream
  (letrec !c = (head stream) !rest = (tail stream) in
    (if (= c '?')
      (tokenize_piend rest)
      (tokenize_pi rest)))
  (error "XML parse error: unexpected end of input in processing instruction"))

tokenize_piend !stream =
(if stream
  (letrec !c = (head stream) !rest = (tail stream) in
    (if (= c '>')
      (tokenize_skipspace rest)
      (tokenize_pi rest)))
  (error "XML parse error: unexpected end of input in processing instruction end"))

tokenize_skipspace !stream =
(if stream
  (letrec !c = (head stream) !rest = (tail stream) in
    (if (isspace c)
      (tokenize_skipspace rest)
      (tokenize_main stream stream 0)))
  nil)

tokenize_namestart !stream =
(if stream
  (letrec !c = (head stream) !rest = (tail stream) in
    (if (= c '/')
      (tokenize_endname rest rest 0)
      (if (= c '?')
        (tokenize_pi rest)
        (if (= c '!')
          (tokenize_comment1 rest stream)
          (tokenize_name stream stream 0)))))
  (error "XML parse error: unexpected end of input at start of element name"))

tokenize_comment1 !stream !start =
(if stream
  (letrec !c = (head stream) !rest = (tail stream) in
    (if (= c '-')
      (tokenize_comment2 rest start)
      (tokenize_name start start 0)))
  (error "XML parse error: unexpected end of input at start of comment"))

tokenize_comment2 !stream !start =
(if stream
  (letrec !c = (head stream) !rest = (tail stream) in
    (if (= c '-')
      (tokenize_comment rest rest 0)
      (tokenize_name start start 0)))
  (error "XML parse error: unexpected end of input at start of comment"))

tokenize_comment !stream !start !count =
(if stream
  (letrec !c = (head stream) !rest = (tail stream) in
    (if (= c '-')
      (tokenize_comment_end1 rest start (+ count 1))
      (tokenize_comment rest start (+ count 1))))
  (error "XML parse error: unexpected end of input in comment"))

tokenize_comment_end1 !stream !start !count =
(if stream
  (letrec !c = (head stream) !rest = (tail stream) in
    (if (= c '-')
      (tokenize_comment_end2 rest start (+ count 1))
      (tokenize_comment rest start (+ count 1))))
  (error "XML parse error: unexpected end of input in comment"))

tokenize_comment_end2 !stream !start !count =
(if stream
  (letrec !c = (head stream) !rest = (tail stream) in
    (if (= c '>')
      (cons (cons TOKEN_COMMENT (prefix (- count 2) start))
        (tokenize_main rest rest 0))
      (tokenize_comment rest start (+ count 1))))
  (error "XML parse error: unexpected end of input in comment"))

tokenize_name !stream !start !count =
(if stream
  (letrec !c = (head stream) !rest = (tail stream) in
    (if (= c '>')
      (cons (cons TOKEN_STARTELEM (prefix count start))
        (tokenize_main rest rest 0))
      (if (= c '/')
        (cons (cons TOKEN_STARTELEM (prefix count start))
          (tokenize_leafend rest))
        (if (isspace c)
          (cons (cons TOKEN_STARTELEM (prefix count start))
            (tokenize_attrsearch rest))
          (tokenize_name rest start (+ count 1))))))
  (error (append "XML parse error: unexpected end of input in open tag: " start)))

tokenize_endname !stream !start !count =
(if stream
  (letrec !c = (head stream) !rest = (tail stream) in
    (if (= c '>')
      (cons (cons TOKEN_ENDELEM nil)
        (tokenize_main rest rest 0))
      (tokenize_endname rest start (+ count 1))))
  (error (append "XML parse error: unexpected end of input in close tag: " start)))

tokenize_leafend !stream =
(if stream
  (letrec !c = (head stream) !rest = (tail stream) in
    (if (= c '>')
      (cons (cons TOKEN_ENDELEM nil)
        (tokenize_main rest rest 0))
      (error (append "XML parse error: invalid character after / in open tag: " stream))))
  (error "XML parse error: unexpected end of input in standalone tag"))

tokenize_attrsearch !stream =
(if stream
  (letrec !c = (head stream) !rest = (tail stream) in
    (if (= c '>')
      (tokenize_main rest rest 0)
      (if (= c '/')
        (tokenize_leafend rest)
        (if (isspace c)
          (tokenize_attrsearch rest)
          (tokenize_attrname rest stream 0)))))
  (error "XML parse error: unexpected end of input in open tag"))

tokenize_attrname !stream !start !count =
(if stream
  (letrec !c = (head stream) !rest = (tail stream) in
    (if (or (= c '=') (isspace c))
      (cons (cons TOKEN_ATTRNAME (prefix (+ count 1) start))
        (tokenize_eqsearch stream))
      (tokenize_attrname rest start (+ count 1))))
  (error "XML parse error: unexpected end of input in attribute name"))

tokenize_eqsearch !stream =
(if stream
  (letrec !c = (head stream) !rest = (tail stream) in
    (if (= c '=')
      (tokenize_valsearch rest)
      (if (isspace c)
        (tokenize_eqsearch rest)
        nil)))
  (error "XML parse error: unexpected end of input in attribute"))

tokenize_valsearch !stream =
(if stream
  (letrec !c = (head stream) !rest = (tail stream) in
    (if (= c '>')
      (tokenize_main rest rest 0)
      (if (= c '\"')
        (tokenize_value_dq rest rest 0)
        (if (= c '\'')
          (tokenize_value_sq rest rest 0)
          (if (isspace c)
            (tokenize_valsearch rest)
            nil)))))
  (error "XML parse error: unexpected end of input in attribute value"))

tokenize_value_dq !stream !start !count =
(if stream
  (letrec !c = (head stream) !rest = (tail stream) in
    (if (= c '\"')
      (cons (cons TOKEN_ATTRVALUE (prefix count start))
        (tokenize_attrsearch rest))
      (tokenize_value_dq rest start (+ count 1))))
  (error "XML parse error: unexpected end of input in attribute value"))

tokenize_value_sq !stream !start !count =
(if stream
  (letrec !c = (head stream) !rest = (tail stream) in
    (if (= c '\'')
      (cons (cons TOKEN_ATTRVALUE (prefix count start))
        (tokenize_attrsearch rest))
      (tokenize_value_sq rest start (+ count 1))))
  (error "XML parse error: unexpected end of input in attribute value"))

isspace c = (or (= c ' ') (or (= c '\r') (= c '\n')))

//==================================================================================================
// xml:print_tokens tokens
//
// Debugging function for printing out the result of the tokenization process
//==================================================================================================

print_tokens !tokens =
(if (not tokens)
  nil
  (letrec
    !tok = (head tokens)
    !rest = (tail tokens)
   in
    (appendn 5 (item (head tok) TOKEN_NAMES) ": \""
      (print_token (tail tok)) "\"\n"
      (print_tokens rest))))

print_token val =
(if val
  (if (= (head val) '\r')
    (append "\\r" (print_token (tail val)))
    (if (= (head val) '\n')
      (append "\\n" (print_token (tail val)))
      (cons (head val) (print_token (tail val)))))
  nil)

//==================================================================================================
// xml:add_whitespace nodes
//
// Produces a new copy of an XML element tree that contains whitespace added for indenting
// purposes. The whitespace is in the form of new text nodes containing a newline and some spaces.
// The indenting is done in accordance with the rules of section 5.1.3 of the XSLT 2.0 and
// XQuery 1.0 Serialization spec, which says that it can only be added in places where it does
// not alter the meaning of the document, i.e. the new whitespace must not be considered
// "significant".
//
// The main part of the work is done by add_whitespace1. This accepts a needindent parameter,
// specifying whether a new element that is encountered should have indentation added before it,
// of in the case of the end of the list, whether whitespace should be added. It also has a
// haveindent parameter, which records the number of characters encountered so far that are the
// same as what would be added; if a document already contains some indentation then only the
// necessary spaces will be added.
//==================================================================================================

add_whitespace nodes =
(add_whitespace1 0 nodes nil 0)

add_whitespace1 depth lst needindent haveindent =
(if lst
  (letrec
    this = (head lst)
    rest = (tail lst)
    type = (item_type this)
   in
    (if (= type TYPE_ELEMENT)
      (letrec
        nsuri = (elem_nsuri this)
        nsprefix = (elem_nsprefix this)
        localname = (elem_localname this)
        attributes = (elem_attributes this)
        namespaces = (elem_namespaces this)
        children = (elem_children this)
       in
        (maybe_indent depth needindent haveindent
          (cons
            (mkelem nsuri nsprefix localname attributes namespaces
              (if children
                (add_whitespace1 (+ depth 1) children 1 0)
                nil))
            (add_whitespace1 depth rest 1 0))))
      (if (= type TYPE_TEXT)
        (letrec
          str = (text_content this)
          newhave = (count_indent str haveindent)
          nws = (isnonws str)
         in
          (cons
            this
            (if nws
              (add_whitespace1 depth rest nil 0)
              (add_whitespace1 depth rest needindent newhave))))
        (if (= type TYPE_COMMENT)
          (maybe_indent depth needindent haveindent
            (cons
              this
              (add_whitespace1 depth rest nil 0)))
          (if (= type TYPE_DOCUMENT)
            (letrec
              children = (doc_children this)
             in
              (cons
                (mkdoc (add_whitespace1 depth children 1 0))
                (add_whitespace1 depth rest nil 0)))
            nil)))))
  (if (> depth 0)
    (maybe_indent (- depth 1) needindent haveindent nil)
    nil))

//==================================================================================================
// xml:count_indent
//
// Count the number of indentation characters present in a string. A set of indentation characters
// consists of a newline followed by one or more spaces. If a non-whitespace character is found,
// then this is the end of a possible indentation string and we must start from the beginning.
// The number of indentation characters already existing in previous text nodes is specified in the
// haveindent argument.
//==================================================================================================
count_indent str haveindent =
(if str
  (letrec
    c = (head str)
    rest = (tail str)
   in
    (if (= c '\n')
      (count_indent rest 1)
      (if (and (= c ' ') (> haveindent 0))
        (count_indent rest (+ haveindent 1))
        (count_indent rest 0))))
  haveindent)

//==================================================================================================
// xml:isnonws str
//
// Determines if a string contains any non-whitespace characters
//==================================================================================================
isnonws str =
//(seq (echo (append "isnonws \"" (append str "\"\n")))
(if str
  (if (isspace (head str))
    (isnonws (tail str))
    1)
  nil)

//==================================================================================================
// xml:maybe_indent depth needindent haveindent rest
//
// This function is used by add_whitespace
//
// Possibly add some whitespace to the document for indentation purposes. This is done only if
// needindent is true. If it is, then the depth and havindent is used to determine how much
// whitespace to add. A haveindent value of 0 means that there is no existing whitespace, and a
// newline and depth*3 spaces should be added. A haveindent value of 1 means that the newline
// is already there, so depth*3 spaces are needed. A haveindent value greater than 1 means that
// the newline is there, as well as (haveindent-1) spaces.
//==================================================================================================
maybe_indent depth needindent haveindent rest =
(if needindent
  (if (> haveindent 0)
    (cons (mktext (spaces (- (* depth 3) (- haveindent 1)))) rest)
    (cons (mktext (append "\n" (spaces (* depth 3)))) rest))
  rest)

//==================================================================================================
// xml:spaces n
//
// Returns a string consisting of n spaces
//==================================================================================================
spaces n =
(letrec
  bulkspaces = (append "                                                            " bulkspaces)
in
(prefix n bulkspaces))

//==================================================================================================
// xml:parse tokens
//
// Construct an XML node tree from a stream of input tokens
//
// This function implements the second half of the logic necessary to create an XML structure from
// a data stream. The function xml:tokenizer must be called to create the token stream, and the
// result passed to this function.
//
// The parser starts off by traversing through the list of tokens. When it encounters a
// START_ELEMENT token, it creates a new element node, with the attributes, namespaces, and
// children constructed from the tokens that appear immediately afterwards. During parsing, the
// current depth is kept track of; this increases when a STARTELEM is encountered, and decreases
// when ENDELEM is encountered. If an ENDELEM token is found and the depth is equal to the current
// depth, then we know that is the end of the set of tokens that comprise the children of this
// element.
//
// In order to parse the next element at this level in the tree, we must skip over all these tokens.
// This is taken care of by the skip_level function. The remainingtokens variable is set to the
// result of this, and the call to parse to create the following sibling of this node is passed
// this set of tokens.
//
// All of the parsing is done lazily. If the caller of this function never accesses parts of the
// tree later on, then these tree segments will never be constructed, and the tokenizer will never
// be asked for the tokens, which means that is is not necessary to read the rest of the data
// stream.
//==================================================================================================

parse tokens =
(letrec
  children = (parse1 tokens nil doc nil 0)
  doc = (mkdoc children)
 in
  (cons doc nil))

parse1 tokens namespaces parent prev !depth =
(if (not tokens)
  (if (> depth 1)
    (error "XML parse error: missing close tag at end of input")
    nil)
  (letrec
    cur = (head tokens)
    rest = (tail tokens)
    tag = (head cur)
   in
    (if (= tag TOKEN_STARTELEM)
      (letrec
        augnamespaces = (cons newnamespaces namespaces)
        children = (skip_attrs rest augnamespaces elem (+ depth 1))
        attributes = (parse_attrs rest augnamespaces)
        newnamespaces = (parse_namespaces rest)
        remainingtokens = (skip_level rest 0)
        qname = (tail cur)
        nsprefix = (getnsprefix qname)
        nsuri = (ns_lookup nsprefix augnamespaces)
        localname = (getlocalname qname)
        elem = (mkelem2 nsuri nsprefix localname attributes newnamespaces children parent prev next)
        next = (parse1 remainingtokens namespaces parent elem depth)
       in
        (cons elem next))
      (if (= tag TOKEN_ENDELEM)
        nil
        (if (= tag TOKEN_ATTRNAME)
          nil
          (if (= tag TOKEN_TEXT)
            (letrec
              text = (mktext2 (tail cur) parent prev next)
              next = (parse1 rest namespaces parent text depth)
             in
              (cons text next))
            (if (= tag TOKEN_COMMENT)
              (letrec
                comment = (mkcomment2 (tail cur) parent prev next)
                next = (parse1 rest namespaces parent comment depth)
               in
                (cons comment next))
              (parse1 rest namespaces parent nil depth))))))))

//==================================================================================================
// xml:skip_attrs tokens namespaces depth
//
// Skip past the ATTRNAME and ATTRVALUE tokens in a token stream.
//
// When the tokenizer parses the open tag of an element, it adds one of each of these tokens for
// each attribute encountered. Any elements, text nodes, comments etc. that are children of the
// element will appear after the attributes. Thus, to get to the portion of the token stream
// representing the children of a node, we simply need to skip past these.
//==================================================================================================
skip_attrs tokens namespaces parent !depth =
(if (not tokens)
  nil
  (letrec
    cur = (head tokens)
    rest = (tail tokens)
    tag = (head cur)
   in
    (if (or (= tag TOKEN_ATTRNAME) (= tag TOKEN_ATTRVALUE))
      (skip_attrs rest namespaces parent depth)
      (parse1 tokens namespaces parent nil depth))))

//==================================================================================================
// xml:parse_namespaces tokens
//
// Constructs a list of namespace mappings based on a set of ATTRNAME and ATTRVALUE tokens.
//
// Each attribute name/value pair in the current element is inspected to see if it is an XML
// namespace declaration, i.e. if it is of the form xmlns:something="..." or xmlns="...". If so,
// a namespace node containing the prefix and namespace URI is created, and added to the list.
// Attributes other than namespace declarations are ignored.
//
// This function looks no further than the attributes specified for this element. If a tag other
// than ATTRNAME or ATTRVALUE is encountered, it means that the next part of the token stream
// corresponds to a child node, or a close tag (the ENDELEM token).
//==================================================================================================
parse_namespaces tokens =
(if (not tokens)
  nil
  (letrec
    cur = (head tokens)
    rest = (tail tokens)
    tag = (head cur)
   in
    (if (= tag TOKEN_ATTRNAME)
      (letrec
        value = (tail (head rest))
        rest2 = (tail rest)
        qname = (tail cur)
        nsprefix = (getnsprefix qname)
        localname = (getlocalname qname)
       in
        (if (streq nsprefix "xmlns")
          (cons
            (mknamespace value localname)
            (parse_namespaces rest2))
          (if (and (not nsprefix) (streq localname "xmlns"))
            (cons
              (mknamespace value nil)
              (parse_namespaces rest2))
            (parse_namespaces rest2))))
      nil)))

//==================================================================================================
// xml:parse_attrs tokens namespaces
//
// Constructs a list of XML attribute nodes corresponding to the ATTRNAME and ATTRVALUE tokens
// found in a token stream.
//
// The token stream is traversed to find the attribute declarations. When a token other than
// ATTRNAME or ATTRVALUE is encountered, this function knows that it has found all the attributes,
// since the next token will either be the first child node or the close tag of the current element.
//
// For each ATTRNAME/ATTRVALUE pair, an attribute node is created, containing the namespace URI,
// prefix, localname, and value. The returned list of nodes is used as the attributes property of
// an element.
//==================================================================================================
parse_attrs tokens namespaces =
(if (not tokens)
  nil
  (letrec
    cur = (head tokens)
    rest = (tail tokens)
    tag = (head cur)
   in
    (if (= tag TOKEN_ATTRNAME)
      (letrec
        value = (tail (head rest))
        rest2 = (tail rest)
        qname = (tail cur)
        nsprefix = (getnsprefix qname)
        nsuri = (ns_lookup nsprefix namespaces)
        localname = (getlocalname qname)

       in
        // Check if it's a namespace attribute; if so, skip this one
        (if (streq nsprefix "xmlns")
          (parse_attrs rest2 namespaces)
          (if (and (not nsprefix) (streq localname "xmlns"))
            (parse_attrs rest2 namespaces)
            // It's a normal attribute; add it to the list
            (cons
              (mkattr nsuri nsprefix localname value)
              (parse_attrs rest2 namespaces)))))
      nil)))

//==================================================================================================
// xml:skip_level tokens level
//
// Skip past the portion of a token stream that contains the tokens for children of a node.
//
// This function is used by the parser to obtain the part of the token stream that needs to be
// parsed for the following sibling of a node. It traverses through the stream, keeping track of
// the current level, based on the appearance of STARTELEM or ENDELEM tokens. When an ENDELEM token
// is found, and the current level is 0, then it returns the remainder of the token stream.
//==================================================================================================
skip_level tokens level =
(if tokens
  (letrec
    cur = (head tokens)
    rest = (tail tokens)
    tag = (head cur)
   in
    (if (= tag TOKEN_STARTELEM)
      (skip_level rest (+ level 1))
      (if (= tag TOKEN_ENDELEM)
        (if (= level 0)
          rest
          (skip_level rest (- level 1)))
        (skip_level rest level))))
  nil)

//==================================================================================================

string_value str = (tail str)
untyped_value untyped = (tail untyped)
number_value num = (tail num)
bool_value bool = (tail bool)
qname_nsuri qname = (item 1 qname)
qname_nsprefix qname = (item 2 qname)
qname_localname qname = (item 3 qname)

mkstring str =
(cons TYPE_STRING str)

mknumber num =
(cons TYPE_NUMBER num)

mkuntyped val =
(cons UNTYPED_ATOMIC val)

mkbool b =
(cons TYPE_BOOLEAN b)

mkqname nsuri nsprefix localname =
(cons TYPE_QNAME
  (cons nsuri
    (cons nsprefix
      (cons localname
        nil))))

item_type item = (head item)


elem_nsuri elem = (item 1 elem)
elem_nsprefix elem = (item 2 elem)
elem_localname elem = (item 3 elem)
elem_attributes elem = (item 4 elem)
elem_namespaces elem = (item 5 elem)
elem_children elem = (item 6 elem)
elem_parent elem = (item 7 elem)
elem_prev elem = (item 8 elem)
elem_next elem = (item 9 elem)

// these three are for elements and attributes only
node_nsuri node = (item 1 node)
node_nsprefix node = (item 2 node)
node_localname node = (item 3 node)


mkelem2 nsuri nsprefix localname attributes namespaces children parent prev next =
(cons TYPE_ELEMENT
  (cons nsuri
    (cons nsprefix
      (cons localname
        (cons attributes
          (cons namespaces
            (cons children
              (cons parent
                (cons prev
                  (cons next nil))))))))))

mkelem nsuri nsprefix localname attributes namespaces children =
(mkelem2 nsuri nsprefix localname attributes namespaces children nil nil nil)

mkdoc children = (cons TYPE_DOCUMENT children)

doc_children doc = (tail doc)

mkattr nsuri nsprefix localname value =
(cons TYPE_ATTRIBUTE
  (cons nsuri
    (cons nsprefix
      (cons localname
        (cons value nil)))))

attr_nsuri attr = (item 1 attr)
attr_nsprefix attr = (item 2 attr)
attr_localname attr = (item 3 attr)
attr_value attr = (item 4 attr)

mknamespace nsuri nsprefix =
(cons TYPE_NAMESPACE
  (cons nsuri
    (cons nsprefix nil)))

namespace_nsuri ns = (item 1 ns)
namespace_nsprefix ns = (item 2 ns)

mktext2 value parent prev next =
(cons TYPE_TEXT
  (cons value
    (cons parent
      (cons prev
        (cons next nil)))))

mktext value =
(mktext2 value nil nil nil)

text_content text = (item 1 text)
text_parent text = (item 2 text)
text_prev text = (item 3 text)
text_next text = (item 4 text)

mkcomment2 value parent prev next =
(cons TYPE_COMMENT
  (cons value
    (cons parent
      (cons prev
        (cons next nil)))))

mkcomment value =
(mkcomment2 value nil nil nil)

comment_content comment = (item 1 comment)
comment_parent comment = (item 2 comment)
comment_prev comment = (item 3 comment)
comment_next comment = (item 4 comment)

node_children node =
(if (= (item_type node) TYPE_ELEMENT)
  (elem_children node)
  (if (= (item_type node) TYPE_DOCUMENT)
    (doc_children node)
    nil))





// Navigation

node_prev node =
(letrec
  type = (item_type node)
 in
  (if (= type TYPE_ELEMENT)
    (elem_prev node)
    (if (= type TYPE_TEXT)
      (text_prev node)
      (if (= type TYPE_COMMENT)
        (comment_prev node)
        nil))))

node_next node =
(letrec
  type = (item_type node)
 in
  (if (= type TYPE_ELEMENT)
    (elem_next node)
    (if (= type TYPE_TEXT)
      (text_next node)
      (if (= type TYPE_COMMENT)
        (comment_next node)
        nil))))

node_parent node =
(letrec
  type = (item_type node)
 in
  (if (= type TYPE_ELEMENT)
    (elem_parent node)
    (if (= type TYPE_TEXT)
      (text_parent node)
      (if (= type TYPE_COMMENT)
        (comment_parent node)
        nil))))













node_attributes node =
(if (= (item_type node) TYPE_ELEMENT)
  (elem_attributes node)
  nil)

node_namespaces node =
(if (= (item_type node) TYPE_ELEMENT)
  (elem_namespaces node)
  nil)

getnsprefix1 str start !count =
(if str
  (if (= (head str) ':')
    (prefix count start)
    (getnsprefix1 (tail str) start (+ count 1)))
  nil)

getnsprefix qname = (getnsprefix1 qname qname 0)

getlocalname1 qname start =
(if qname
  (if (= (head qname) ':')
    (tail qname)
    (getlocalname1 (tail qname) start))
  start)

getlocalname qname = (getlocalname1 qname qname)

get_attribute1 nsuri localname attrs =
(if attrs
  (letrec
    attr = (head attrs)
   in
    (if
      (and
        (streq (attr_nsuri attr) nsuri)
        (streq (attr_localname attr) localname))
      (attr_value attr)
      (get_attribute1 nsuri localname (tail attrs))))
  nil)

get_attribute nsuri localname elem =
(get_attribute1 nsuri localname (elem_attributes elem))

ns_lookup1 nsprefix lst =
(if lst
  (letrec
    ns = (head lst)
    value = (namespace_nsuri ns)
    prefix = (namespace_nsprefix ns)
   in
    (if (streq prefix nsprefix)
      value
      (ns_lookup1 nsprefix (tail lst))))
  nil)

ns_lookup2 nsprefix nslists =
(if nslists
  (letrec
    nsuri = (ns_lookup1 nsprefix (head nslists))
   in
    (if nsuri
      nsuri
      (ns_lookup2 nsprefix (tail nslists))))
  nil)

ns_lookup nsprefix nslists =
(if (streq nsprefix "xmlns")
  XMLNS_NS
  (ns_lookup2 nsprefix nslists))

// FIXME: need to escape element/attribute names and values when printing

apmap lst fun = (if lst (append (fun (head lst)) (apmap (tail lst) fun)) nil)

print_attrs lst next =
(if lst
  (letrec
    attr = (head lst)
    nsuri = (attr_nsuri attr)
    nsprefix = (attr_nsprefix attr)
    localname = (attr_localname attr)
    qname = (if nsprefix (append nsprefix (cons ':' localname)) localname)
    //qname = (if nsuri (cons '{' (append nsuri (cons '}' localname))) localname)
   in
    (append " "
      (append qname
        (append "=\""
          (append (attr_value attr)
            (append "\"" (print_attrs (tail lst) next)))))))
  next)

print_namespaces lst next =
(if lst
  (letrec
    cur = (head lst)
    nsuri = (namespace_nsuri cur)
    nsprefix = (namespace_nsprefix cur)
   in
    (append " xmlns:"
      (append nsprefix
        (append "=\""
          (append nsuri
            (append "\"" (print_namespaces (tail lst) next)))))))
  next)

print_nodes lst next =
(if lst
  (letrec
    node = (head lst)
    rest = (tail lst)
   in
    (if (= (item_type node) TYPE_ELEMENT)
      (letrec
        nsuri = (elem_nsuri node)
        nsprefix = (elem_nsprefix node)
        localname = (elem_localname node)
        attributes = (elem_attributes node)
        namespaces = (elem_namespaces node)
        children = (elem_children node)
        qname = (if nsprefix (append nsprefix (cons ':' localname)) localname)
        //qname = (if nsuri (cons '{' (append nsuri (cons '}' localname))) localname)
       in
        (if children
          (cons '<'
            (append qname
              (print_namespaces namespaces
                (print_attrs attributes
                  (cons '>'
                    (print_nodes children
                      (cons '<'
                        (cons '/'
                          (append qname
                            (append ">"
                              (print_nodes rest next)))))))))))
          (cons '<'
            (append qname
              (print_namespaces namespaces
                (print_attrs attributes
                  (append "/>" (print_nodes rest next))))))))
      (if (= (item_type node) TYPE_TEXT)
        (append (text_content node) (print_nodes rest next))
        (if (= (item_type node) TYPE_COMMENT)
          (append "<!--" (append (comment_content node) (append "-->" (print_nodes rest next))))
          (if (= (item_type node) TYPE_DOCUMENT)
            (print_nodes (node_children node) (print_nodes rest next))
            (append "OTHER: " (append (numtostring (item_type node)) (print_nodes rest next))))))))
  next)

////////////////////////////////////////////////////////////////////////////////

stripspaces lst parent prev =
(if lst
  (letrec
    cur = (head lst)
    rest = (tail lst)
    type = (item_type cur)
   in
    (if (= type TYPE_ELEMENT)
      (letrec
        elem =
        (mkelem2
          (elem_nsuri cur)
          (elem_nsprefix cur)
          (elem_localname cur)
          (elem_attributes cur)
          (elem_namespaces cur)
          (stripspaces (elem_children cur) elem nil)
          parent
          prev
          next)
        next =
        (stripspaces rest parent elem)
       in
        (cons elem next))
      (if (= type TYPE_TEXT)
        (if (isnonws (text_content cur))
          (letrec
            content = (text_content cur)
            text = (mktext2 content parent prev next)
            next = (stripspaces rest parent text)
           in
            (cons text next))
          (stripspaces rest parent prev))
        (if (= type TYPE_COMMENT)
          (letrec
            content = (comment_content cur)
            comment = (mkcomment2 content parent prev next)
            next = (stripspaces rest parent comment)
           in
            (cons comment next))
          (if (= type TYPE_DOCUMENT)
            (letrec
              doc = (mkdoc (stripspaces (doc_children cur) doc nil))
             in
              (cons doc nil))
            (cons cur (stripspaces rest parent cur)))))))
  nil)

parsexml strip stream =
(letrec
 input = (parse (tokenize stream))
 input2 = (if strip (stripspaces input nil nil) input)
 in
  (head input2))

printxml indent root =
(letrec
  raw = (cons root nil)
  nodes = (if indent (add_whitespace raw) raw)
 in
  (append XML_DECL (print_nodes nodes nil)))
